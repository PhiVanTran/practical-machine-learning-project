<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Human Activity Recognition</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>
<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Human Activity Recognition</h1>

<h2>Getting the data</h2>

<pre><code class="r">dim(pmltraining)
</code></pre>

<pre><code>## [1] 19622   160
</code></pre>

<pre><code class="r">dim(pmltesting)
</code></pre>

<pre><code>## [1]  20 160
</code></pre>

<p>It&#39;s a large data set, 19622 cases and 160 variables.  There are 20 cases provided as &ldquo;unknowns&rdquo; to used as test cases.</p>

<p>The first 159 variables are potential predictors. Variable 160 is the response variable, &ldquo;classe&rdquo;, for the training set. for the testing set, variable 160,  &ldquo;problem_id&rdquo;,  gives the problem number, keyed to the 20 problems to be submitted to the Coursera/Johns Hopkins Practical Machine Learning course.</p>

<pre><code class="r">class(pmltraining[,160])
</code></pre>

<pre><code>## [1] &quot;factor&quot;
</code></pre>

<pre><code class="r">table(pmltraining[,160])
</code></pre>

<pre><code>## 
##    A    B    C    D    E 
## 5580 3797 3422 3216 3607
</code></pre>

<p>There are 5 response levels, A, B, C, D, and E. Given values for the first 159 variables, our task is to predict the response A, B, C, D, and E.</p>

<h2>Cleaning the data</h2>

<p>There is plenty of missing data.  Let&#39;s quantify that observation, checking the fraction of NAs for each variable.</p>

<pre><code class="r">naCount = integer()
naFraction = numeric()
numcoltraining &lt;-  ncol(pmltraining)
numrowtraining &lt;-  nrow(pmltraining)
for(n in 1:numcoltraining) {
        naCount[n] &lt;- sum(is.na(pmltraining[,n]))
        naFraction[n] &lt;- naCount[n]/numrowtraining
}
checknas &lt;- data.frame(names(pmltraining), naFraction)
checknas
</code></pre>

<pre><code>##           names.pmltraining. naFraction
## 1                          X  0.0000000
## 2                  user_name  0.0000000
## 3       raw_timestamp_part_1  0.0000000
## 4       raw_timestamp_part_2  0.0000000
## 5             cvtd_timestamp  0.0000000
## 6                 new_window  0.0000000
## 7                 num_window  0.0000000
## 8                  roll_belt  0.0000000
## 9                 pitch_belt  0.0000000
## 10                  yaw_belt  0.0000000
## 11          total_accel_belt  0.0000000
## 12        kurtosis_roll_belt  0.0000000
## 13       kurtosis_picth_belt  0.0000000
## 14         kurtosis_yaw_belt  0.0000000
## 15        skewness_roll_belt  0.0000000
## 16      skewness_roll_belt.1  0.0000000
## 17         skewness_yaw_belt  0.0000000
## 18             max_roll_belt  0.9793089
## 19            max_picth_belt  0.9793089
## 20              max_yaw_belt  0.0000000
## 21             min_roll_belt  0.9793089
## 22            min_pitch_belt  0.9793089
## 23              min_yaw_belt  0.0000000
## 24       amplitude_roll_belt  0.9793089
## 25      amplitude_pitch_belt  0.9793089
## 26        amplitude_yaw_belt  0.0000000
## 27      var_total_accel_belt  0.9793089
## 28             avg_roll_belt  0.9793089
## 29          stddev_roll_belt  0.9793089
## 30             var_roll_belt  0.9793089
## 31            avg_pitch_belt  0.9793089
## 32         stddev_pitch_belt  0.9793089
## 33            var_pitch_belt  0.9793089
## 34              avg_yaw_belt  0.9793089
## 35           stddev_yaw_belt  0.9793089
## 36              var_yaw_belt  0.9793089
## 37              gyros_belt_x  0.0000000
## 38              gyros_belt_y  0.0000000
## 39              gyros_belt_z  0.0000000
## 40              accel_belt_x  0.0000000
## 41              accel_belt_y  0.0000000
## 42              accel_belt_z  0.0000000
## 43             magnet_belt_x  0.0000000
## 44             magnet_belt_y  0.0000000
## 45             magnet_belt_z  0.0000000
## 46                  roll_arm  0.0000000
## 47                 pitch_arm  0.0000000
## 48                   yaw_arm  0.0000000
## 49           total_accel_arm  0.0000000
## 50             var_accel_arm  0.9793089
## 51              avg_roll_arm  0.9793089
## 52           stddev_roll_arm  0.9793089
## 53              var_roll_arm  0.9793089
## 54             avg_pitch_arm  0.9793089
## 55          stddev_pitch_arm  0.9793089
## 56             var_pitch_arm  0.9793089
## 57               avg_yaw_arm  0.9793089
## 58            stddev_yaw_arm  0.9793089
## 59               var_yaw_arm  0.9793089
## 60               gyros_arm_x  0.0000000
## 61               gyros_arm_y  0.0000000
## 62               gyros_arm_z  0.0000000
## 63               accel_arm_x  0.0000000
## 64               accel_arm_y  0.0000000
## 65               accel_arm_z  0.0000000
## 66              magnet_arm_x  0.0000000
## 67              magnet_arm_y  0.0000000
## 68              magnet_arm_z  0.0000000
## 69         kurtosis_roll_arm  0.0000000
## 70        kurtosis_picth_arm  0.0000000
## 71          kurtosis_yaw_arm  0.0000000
## 72         skewness_roll_arm  0.0000000
## 73        skewness_pitch_arm  0.0000000
## 74          skewness_yaw_arm  0.0000000
## 75              max_roll_arm  0.9793089
## 76             max_picth_arm  0.9793089
## 77               max_yaw_arm  0.9793089
## 78              min_roll_arm  0.9793089
## 79             min_pitch_arm  0.9793089
## 80               min_yaw_arm  0.9793089
## 81        amplitude_roll_arm  0.9793089
## 82       amplitude_pitch_arm  0.9793089
## 83         amplitude_yaw_arm  0.9793089
## 84             roll_dumbbell  0.0000000
## 85            pitch_dumbbell  0.0000000
## 86              yaw_dumbbell  0.0000000
## 87    kurtosis_roll_dumbbell  0.0000000
## 88   kurtosis_picth_dumbbell  0.0000000
## 89     kurtosis_yaw_dumbbell  0.0000000
## 90    skewness_roll_dumbbell  0.0000000
## 91   skewness_pitch_dumbbell  0.0000000
## 92     skewness_yaw_dumbbell  0.0000000
## 93         max_roll_dumbbell  0.9793089
## 94        max_picth_dumbbell  0.9793089
## 95          max_yaw_dumbbell  0.0000000
## 96         min_roll_dumbbell  0.9793089
## 97        min_pitch_dumbbell  0.9793089
## 98          min_yaw_dumbbell  0.0000000
## 99   amplitude_roll_dumbbell  0.9793089
## 100 amplitude_pitch_dumbbell  0.9793089
## 101   amplitude_yaw_dumbbell  0.0000000
## 102     total_accel_dumbbell  0.0000000
## 103       var_accel_dumbbell  0.9793089
## 104        avg_roll_dumbbell  0.9793089
## 105     stddev_roll_dumbbell  0.9793089
## 106        var_roll_dumbbell  0.9793089
## 107       avg_pitch_dumbbell  0.9793089
## 108    stddev_pitch_dumbbell  0.9793089
## 109       var_pitch_dumbbell  0.9793089
## 110         avg_yaw_dumbbell  0.9793089
## 111      stddev_yaw_dumbbell  0.9793089
## 112         var_yaw_dumbbell  0.9793089
## 113         gyros_dumbbell_x  0.0000000
## 114         gyros_dumbbell_y  0.0000000
## 115         gyros_dumbbell_z  0.0000000
## 116         accel_dumbbell_x  0.0000000
## 117         accel_dumbbell_y  0.0000000
## 118         accel_dumbbell_z  0.0000000
## 119        magnet_dumbbell_x  0.0000000
## 120        magnet_dumbbell_y  0.0000000
## 121        magnet_dumbbell_z  0.0000000
## 122             roll_forearm  0.0000000
## 123            pitch_forearm  0.0000000
## 124              yaw_forearm  0.0000000
## 125    kurtosis_roll_forearm  0.0000000
## 126   kurtosis_picth_forearm  0.0000000
## 127     kurtosis_yaw_forearm  0.0000000
## 128    skewness_roll_forearm  0.0000000
## 129   skewness_pitch_forearm  0.0000000
## 130     skewness_yaw_forearm  0.0000000
## 131         max_roll_forearm  0.9793089
## 132        max_picth_forearm  0.9793089
## 133          max_yaw_forearm  0.0000000
## 134         min_roll_forearm  0.9793089
## 135        min_pitch_forearm  0.9793089
## 136          min_yaw_forearm  0.0000000
## 137   amplitude_roll_forearm  0.9793089
## 138  amplitude_pitch_forearm  0.9793089
## 139    amplitude_yaw_forearm  0.0000000
## 140      total_accel_forearm  0.0000000
## 141        var_accel_forearm  0.9793089
## 142         avg_roll_forearm  0.9793089
## 143      stddev_roll_forearm  0.9793089
## 144         var_roll_forearm  0.9793089
## 145        avg_pitch_forearm  0.9793089
## 146     stddev_pitch_forearm  0.9793089
## 147        var_pitch_forearm  0.9793089
## 148          avg_yaw_forearm  0.9793089
## 149       stddev_yaw_forearm  0.9793089
## 150          var_yaw_forearm  0.9793089
## 151          gyros_forearm_x  0.0000000
## 152          gyros_forearm_y  0.0000000
## 153          gyros_forearm_z  0.0000000
## 154          accel_forearm_x  0.0000000
## 155          accel_forearm_y  0.0000000
## 156          accel_forearm_z  0.0000000
## 157         magnet_forearm_x  0.0000000
## 158         magnet_forearm_y  0.0000000
## 159         magnet_forearm_z  0.0000000
## 160                   classe  0.0000000
</code></pre>

<p>Thus it turns out that the variables divide neatly into two sets, those with no missing data and those with over 97 percent NAs. We begin to build the cleaner <em>training</em> and <em>testing</em> sets we will actually use by selecting just the variables without missing data.</p>

<pre><code class="r">goodvarsL &lt;-  naFraction &lt; 0.01 
sum(goodvarsL)
</code></pre>

<pre><code>## [1] 93
</code></pre>

<pre><code class="r">max(naCount[goodvarsL])
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">training &lt;- pmltraining[, names(pmltraining)[goodvarsL] ]
testing &lt;- pmltesting[, names(pmltesting)[goodvarsL] ]
dim(training)
</code></pre>

<pre><code>## [1] 19622    93
</code></pre>

<pre><code class="r">dim(testing)
</code></pre>

<pre><code>## [1] 20 93
</code></pre>

<p>We have reduced the number of variables from 160 to 93.</p>

<p>The variable X is a unique identifier for the cases, so it is not useful for prediction. We drop it.</p>

<pre><code class="r">training &lt;- training[ , !names(training)==&quot;X&quot;]
testing &lt;-  testing[ , !names(testing)==&quot;X&quot;]
</code></pre>

<p>We will build our predictor with a random forest.   We plan to use the caret package, which calls randomForest command, which at present does not accept categorical predictor variables with 32 or more levels. Since there are some in the training data set, we remove them.</p>

<pre><code class="r">numcol &lt;- ncol(training)
varkeep &lt;- rep(TRUE, numcol)
for (n in 1:(numcol-1) ) {
        temp &lt;- training[ ,n]
        if ( class(temp) == &quot;factor&quot; )   {
                if (nlevels(temp) &gt;= 32) {
                        varkeep[n] &lt;- FALSE
                }         
        }     
}
sum(varkeep) 
</code></pre>

<pre><code>## [1] 68
</code></pre>

<p>So we only keep 67 predictor variables and the 1 response variable.</p>

<pre><code class="r">train1 &lt;- training[,varkeep]
test &lt;- testing[,varkeep]
dim(train1)
</code></pre>

<pre><code>## [1] 19622    68
</code></pre>

<p>But now we note that 9 of the variables in the 20 case test set are missing all data.  We remove those variables from the data set.</p>

<pre><code class="r">badTestVars &lt;- c(&quot;kurtosis_yaw_belt&quot;, &quot;skewness_yaw_belt&quot;, &quot;amplitude_yaw_belt&quot;, &quot;kurtosis_yaw_dumbbell&quot;, &quot;skewness_yaw_dumbbell&quot;, &quot;amplitude_yaw_dumbbell&quot;, &quot;kurtosis_yaw_forearm&quot;, &quot;skewness_yaw_forearm&quot;, &quot;amplitude_yaw_forearm&quot; )
train1 &lt;- train1[,!(names(train1) %in% badTestVars )]
dim(train1)
</code></pre>

<pre><code>## [1] 19622    59
</code></pre>

<pre><code class="r">test &lt;- test[,!(names(test) %in% badTestVars )]
dim(test)
</code></pre>

<pre><code>## [1] 20 59
</code></pre>

<p>So in the end we  only keep 58 predictor variables and the 1 response variable.</p>

<h2>Separating off a cross-validation set for checking out-of-sample accuracy</h2>

<p>Because it takes so long to run the full data set, we run it on only part of the data.  We take a random selection of 10000 of the 19622 observations</p>

<pre><code class="r">set.seed(12345)
nsample &lt;- 10000
samples &lt;- sample(nrow(train1), size = nsample)
train1 &lt;- train1[samples,]
</code></pre>

<p>We partition our training data set train1 into two subsets:  train2 contains 90% of the cases and will be used to train the predictor.  crossval2 contains 10% of the cases and will be used to make an out of sample estimate of the accuracy. </p>

<pre><code class="r">long &lt;- nrow(train1)
trainrows &lt;- sample(long, size = round(0.9*long))
crossvrows &lt;- c(1:long)[is.na(pmatch(x=c(1:long), table = trainrows))]
train2 &lt;- train1[trainrows,]
crossval2 &lt;- train1[crossvrows,]
dim(train2)
</code></pre>

<pre><code>## [1] 9000   59
</code></pre>

<pre><code class="r">dim(crossval2)
</code></pre>

<pre><code>## [1] 1000   59
</code></pre>

<h2>Building and evaluating the predictor</h2>

<p>We use the caret package to build a random forest predictor.  It takes about 5 hours to run on our reduced data set, so we save the predictor as an RDS file for future use, enabling us to deactivate the train command command during final editing of the rmd file. During the editing, we read in the modFit1 file that the train command produced the first time through.</p>

<pre><code class="r">library(randomForest)
library(caret)
modFit1 <- train(classe~ ., data=train2, method="rf", prox=TRUE)
modFit1
saveRDS(modFit1, &quot;model10000alt.RDS&quot;)
</code></pre>

<pre><code class="r">modFit1 = readRDS(&quot;model10000alt.RDS&quot;)
modFit1
</code></pre>

<pre><code>## Random Forest 
## 
## 9000 samples
##   58 predictor
##    5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## 
## Summary of sample sizes: 9000, 9000, 9000, 9000, 9000, 9000, ... 
## 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa      Accuracy SD  Kappa SD   
##    2    0.9818070  0.9769455  0.002247714  0.002846477
##   41    0.9962250  0.9952177  0.001156905  0.001465557
##   80    0.9942724  0.9927439  0.001385028  0.001755431
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 41.
</code></pre>

<p>Now for a prediction on the cross validation set.  We are able to compare the predictions with the true values on 1000 cases that are not part of the training set.</p>

<pre><code class="r">predictCrossVal &lt;- predict(modFit1, crossval2)
rightOrWrong &lt;- predictCrossVal == crossval2[, &quot;classe&quot;]
table(rightOrWrong)
</code></pre>

<pre><code>## rightOrWrong
## FALSE  TRUE 
##     1   999
</code></pre>

<pre><code class="r">accuracy &lt;- sum(rightOrWrong)/length(rightOrWrong)
accuracy
</code></pre>

<pre><code>## [1] 0.999
</code></pre>

<p>The predictor was correct in 999 out of 1000 cases in the cross-validation set, an accuracy of 99.9%.   The estimated out-of-sample error rate is 0.1%.</p>

<h2>Predicting the unknown test set</h2>

<p>Finally, we use our predictor to classify the twenty observations with unknown solution that constitute the Practical Machine Learning course problem set.</p>

<pre><code class="r">predictVars1 &lt;- predict(modFit1, test)
predictVars1
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

</body>

</html>


